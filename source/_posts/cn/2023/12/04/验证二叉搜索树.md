---
title: 验证二叉搜索树
catalog: true
date: 2023-12-04 16:22:29
subtitle:
tags:
- 算法
categories: 
- 算法
header-img: /img/header_img/lml_bg.jpg
---
# 验证二叉搜索树
## 题目描述   
  [leetcode NO-98.](https://leetcode.cn/problems/validate-binary-search-tree/description/) 难度中等
  给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含 小于 当前节点的数。
- 节点的右子树只包含 大于 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

**示例 1：**  
![img.png](img.png)

**输入：** root = [2,1,3]
**输出：** true  
  

**示例 2：**  
![img_1.png](img_1.png)

**输入：**  root = [5,1,4,null,null,3,6]  
**输出：**  false  
**解释：**  根节点的值是 5 ，但是右子节点的值是 4 。  


**提示：**

树中节点数目范围在[1, 10^4] 内
-2^31 <= Node.val <= 2^31 - 1  

## 解题思路：  
> 二叉树是不是二叉搜索树，可以分解为左子树、右子树是否是二叉搜索树，使用递归方式一层层往下找直到触发边界条件（当前节点为null或者当前节点不符合二叉搜索树的节点值规律-左子树<根<右子树）
## 代码：
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isValidBST(TreeNode root) {
        // 二叉树是不是二叉搜索树，可以分解为左子树、右子树是否是二叉搜索树
        return valid(root, null,null);
    }
    public boolean valid(TreeNode node, Integer low, Integer high) {
        if(node == null) return true;
        int val = node.val;
        if (low != null && val <= low) return false;
        if (high != null && val >= high) return false;
        return valid(node.left, low, val) && valid(node.right, val, high);
    }
}
```